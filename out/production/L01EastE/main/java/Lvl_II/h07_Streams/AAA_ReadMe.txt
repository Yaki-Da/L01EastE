 *  Stream - это последовательность элементов, поддерживающих последовательные и параллельные
 *          операции над ними. (Поток данных, коллекций и массивов)
 *          stream содержит классы для поддержки операций с потоками элементов в функциональном стиле.
 *          Ключевой абстракцией, введенной в этом пакете, является Поток. Stream API – по сути
 *          это поток данных и последовательные операции над ними. После использования считается завершеным.
 *  Stream.map(i) преобразует каждый элемент потока с помощью функции, переданной в виде лямбда-
 *          -выражения или ссылки на метод. В результате создаётся новый поток, содержащий преобразованные
 *          элементы, без изменения исходного потока.
 *  Stream.filter(i) Метод фильтра может быть вызван для потока. Он принимает предикат в качестве
 *          входных данных и возвращает поток. Вместо того, чтобы влиять на исходный поток, он
 *          генерирует и возвращает новый поток . Метод фильтра происходит из универсального интерфейса
 *          Stream, что подразумевает, что его можно применять ко всем типам данных и классам.
 *  Stream.forEach(t) перебор коллекции или массива в потоке. При более больших операциях над коллекциями
 *          потоковый перебор более актуален.
 *  Stream.reduce(t) используется для выполнения сокращения элементов потока с использованием
 *          ассоциативной функции накопления и возвращает Optional . Он обычно используется
 *          для агрегации или объединения элементов в один результат, например, для вычисления
 *          максимума, минимума, суммы или произведения.
 *  Stream.sorted(i) — это метод интерфейса Stream, который возвращает отсортированный поток.
 *          Элементы потока сортируются в соответствии с их естественным порядком или в соответствии
 *          с предоставленным Comparator . Отсортированный поток является новым и не влияет
 *          на порядок элементов в исходном потоке.
 *  Chaining Method - Это известно как цепочка потоков. Например, производные классы класса
 *          FilterInputStream принимают входные данные из потока и фильтруют их так, что когда
 *          мы считываем данные из этого потока, мы получаем отфильтрованные входные данные.
 *          Потоки Java не являются структурой данных и не могут изменять данные; они могут
 *          только преобразовывать данные. Потоки Java позволяют выполнять операции в функциональном
 *          стиле над потоками элементов.
 *          (Source -> Intermedia Methods (lazy) -> Terminal Methods (eager))
 *          lazy - промежуточные методы, начнут выполняться как определится терминальный
 *          eager - конечный метод, сразуреализованный метод в цепочке данных
 *  Stream.concat() — это оптимальное решение для объединения двух потоков, преимущество которого
 *          — эффективность и ленивость исполнения. Возможности этого метода со временем были
 *          расширены, превращая его из метода экземпляра в статический, благодаря чему первоначальные
 *          проблемы с null-аргументами были успешно решены. нельзя использовать в цепочке (Chaining)
 *  Stream.distinct(i) - это промежуточная операция, которая удаляет дубликаты из потока.
 *  Stream.count(t) - выводит количество элементов в потоке.
 *  Stream.peek(i) - Этот метод существует в основном для поддержки отладки, когда вы хотите
 *          видеть элементы по мере их прохождения через определенную точку конвейера.
 *  Stream.flatMap(i) позволяет сформировать массив, применяя функцию к каждому элементу, затем
 *          уменьшает вложенность, делая этот массив плоским, и возвращает его.
 *          Работает с элементами наших под элементов запуская на каждый из них в один общий поток
 *  Stream.collect(t) используется для того, чтобы перейти от потоков к привычным коллекциям — List<T>
 *          , Set<T> , Map<T, R> и другим. В метод collect() нужно передать специальный объект — collector
 *     .collect(Collectors.groupingBy()) - для группировки элементов используется метод
 *          Collectors. groupingBy . Этот метод принимает функцию классификации, которая определяет,
 *          как элементы будут сгруппированы.
 *     .collect(Collectors.partitioningBy()) - имеет похожее действие, только он делит элементы
 *          на группы по принципу, соответствует ли элемент определенному условию.
 *  Stream.findFirst(t) возвращает первый элемент по порядку из Stream-a, в виде обертки Optional.
 *  Stream.min(t).max(t) возвращает максимальное или минимальное значение.
 *  Stream.limit(i) принимает указанное количество вариаций.
 *  Stream.skip(i) пропускает указанное количество вариаций.
 *  Stream.mapToInt(i) выводит из списка стрим в список элементов Integer
 *  это возможность использования нескольких ядер процессора при выполнении каких либо операций со stream
