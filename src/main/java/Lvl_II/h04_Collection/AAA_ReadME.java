package Lvl_II.h04_Collection;

public class AAA_ReadME {
/**
*   01.Set — это интерфейс, объявленный в пакете java. util . Он расширяет
*      интерфейс коллекции, позволяющий создавать неупорядоченную коллекцию или список,
*      в котором не допускаются повторяющиеся значения. Как следует из названия, set в
*      Java используется для создания математического множества.
*   02.HashSet в Java - это реализация интерфейса Set , который использует хэш-таблицы
*      для хранения элементов коллекции. HashSet не гарантирует порядок элементов
*      при их переборе, и не допускает хранение дублирующихся элементов.
*   03.LinkedHashSet – это HashSet, в котором элементы хранятся еще и в связном списке. Булевы операции!!!
*   04.TreeSet – это коллекция, которая хранит элементы в виде упорядоченного по значениям
*      дерева. Внутри TreeSet<E> содержится TreeMap<E, Object> который и хранит все эти значения.
*   05.List - представляет собой интерфейс, предусматривающий совокупность методов для
*      работы с последовательностями элементов.
*   06.ArrayList — это конкретный класс, осуществляющий этот интерфейс, зиждённый на
*      массивах, что делает его идеальным для быстрого доступа к элементам и эффективных
*      модификаций в конце списка.
*   07.Итератор — это поведенческий паттерн, позволяющий последовательно обходить сложную
*      коллекцию, без раскрытия деталей её реализации. Благодаря Итератору, клиент может
*      обходить разные коллекции одним и тем же способом, используя единый интерфейс итераторов.
*   08.LinkedList — класс, реализующий два интерфейса — List и Deque.Это обеспечивает
*      возможность создания двунаправленной очереди из любых (в том числе и null) элементов.
*      Каждый объект, помещенный в связанный список, является узлом (нодом). Каждый узел
*      содержит элемент, ссылку на предыдущий и следующий узел. Удобен для удаления или
*      вставки элемента в середине списка.
*   09.ListIterator — это Java Iterator, который используется для итерации элементов по
*      одному из объекта, реализованного List: void add(E obj): вставляет объект obj перед
*      элементом, который должен быть возвращен следующим вызовом next()
*   10.Big O - как раз придумана для описания алгоритмической сложности. Она призвана показать,
*      как сильно увеличится количество операций при увеличении размера данных. Вот некоторые
*      примеры того, как записывается сложность: O(1), O(n), O(nlog(n)). O(1) описывает
*      константную (постоянную) сложность.
*   11.Vector является реализацией динамического массива, который похож на ArrayList за
*      исключением того, что: Класс Vector содержит много устаревших методов, которые не являются
*      частью Collection Framework.
*   12.Stack – это подкласс Vector, который реализует стандартный стек last-in, first-out.
*   13.Map – это коллекция ключ/значение, как и Object . Но основное отличие в том, что Map
*      позволяет использовать ключи любого типа. Методы и свойства: new Map() – создаёт коллекцию.
*   14.HashMap — это структура данных в Java, которая реализует интерфейс Map. Она хранит
*      пары "ключ-значение" и обеспечивает быстрый доступ к значениям по ключам.
*      1. **Быстрый доступ**: Среднее время доступа к элементам — O(1).
*      2. **Неупорядоченность**: Элементы не хранятся в каком-либо определённом порядке.
*      3. **Допустимые значения**: Ключи могут быть уникальными, значения — нет. Допускаются
*           null-ключи и null-значения.
*      4. **Не синхронизирован**: Не является потокобезопасным, но может быть обернут в
*           Collections.synchronizedMap()  для безопасного использования в многопоточной среде.
*      HashMap часто используется для реализации кэшей, хранения данных и быстрого поиска.
*   15.HashCode - Он возвращает целочисленное значение, используемое для идентификации объекта. Для
*      вычисления Java использует алгоритм хеширования, который преобразует данные объекта в
*      целочисленное значение. Реализация алгоритма зависит от JVM.
*      Общий контракт метода hashCode() таков: многократные вызовы hashCode() должны возвращать
*      одно и то же целочисленное значение, если только не изменено свойство объекта,
*      используемое в методе equals().
*   16.TreeMap - Это структура данных, похожая на словарь, которая позволяет сохранять элементы в
*      виде ключ-значение, используя сортировку по ключам. (Схожа с биннарным поиском но хранением)
*      HashMap позволяет иметь ключ null и значение null. HashTable не позволяет ключ null или
*        значение null. Если TreeMap использует естественный порядок или компаратор не позволяет
*        использовать ключ null, будет выброшено исключение.
*   17.LinkedHashMap реализован как корзина со списком с двойной связью (double-linked list bucket),
*      HashMap реализован как хэш-таблица, а TreeMap реализован по древовидному принципу.
*      LinkedHashMap — это структура данных в Java, которая также реализует интерфейс Map, но в
*      отличие от HashMap, сохраняет порядок вставки элементов. Основные характеристики:
*      1. **Порядок элементов**: Сохраняет порядок добавления элементов, что позволяет
*           итерироваться по ним в том порядке, в котором они были добавлены.
*      2. **Быстрый доступ**: Среднее время доступа к элементам — O(1), как и у HashMap.
*      3. **Допустимые значения**: Ключи уникальны, значения могут повторяться; допускаются
*           null-ключи и null-значения.
*      4. **Не синхронизирован**: Не является потокобезопасным, но может быть обернут в
*           Collections.synchronizedMap() .
*   18.Queue - это коллекция, хранящая последовательность элементов. Добавляется элемент в конец очереди,
*      используется из начала очереди - правило FIFO. Queue -> Degue & AbstractQueue
*      Его смысл в постоянной обработке первого головного эелемента
*      add добавить offer добавить с обработкой ошибки
*      remove удалить pool удалть с обработкой ошибки
*      element вывод первого элемента peek вывод первого эелемента с обработкой ошибки
*   19.PriorityQueue - это коллекция такая как Queue но сортированная по возрастанию (обязательно
*      переопределять методы). При выводе на экран сортировка не проводится, при работе с эелементами
*      ведет по сортировочному приоритету.
*   20.Deque - double ended queue (двухнаправленная очередь). В такой очереди элементы могут
*      использоваться с обоих концов. Здесь работают оба правила - FIFO и LIFO
*      Deque<Integer> degue = new ArrayDeque<>();
*      addFirst addLast offerFirst offerLast (без обработки ошибки / с обработкой ошибки)
*      removeFirst removeLast pollFirst pollLast (без обработки ошибки / с обработкой ошибки)
*      getFirst getLast peekFirst peekLast (без обработки ошибки / с обработкой ошибки)
**/

}
